#!/usr/bin/perl

# COPYRIGHT:
#
# This software is Copyright (c) 2007-2009 NETWAYS GmbH, Christian Doebler
#                 some parts (c) 2009      NETWAYS GmbH, William Preston
#                                <support@netways.de>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:GPL2
# see noma_daemon.pl in parent directory for full details.
# Please do not distribute without the above file!

use threads;
use Thread::Queue;
use IO::Select;
use Fcntl qw(O_RDWR);
use IO::Socket;
use FindBin;
use lib "$FindBin::Bin";
use debug;


# run a command notifier and return the result
# N.B. be sure to implement timeouts in the notifier
# otherwise the thread will block
sub spawnNotifierThread
{

    my ( $inqueue, $outqueue, $name, $cmd ) = @_;
    my $timeToWait;

    NOTIFIERLOOP: while ( my $msg = $inqueue->dequeue )
    {
        my ( $id, $start, $count, $param ) = split( ';', $msg, 4 );

	# check for retries
    debug("$name: $id received");

	if ($count > 1)
	{
        debug("BUG in NoMa. This code should not be called (count=$count)");
		# retry - check if it is old enough to be retried
		
		$timeToWait = $conf->{notifier}->{timeToWait};
		if (!(defined($timeToWait)))
		{
			$timeToWait = 60;
		}

		# be careful! we don't use timezones
		if (($start + $timeToWait) > time())
		{
			# notification is not old enough, requeue
			$inqueue->enqueue("$id;$start;$count;$param");

			# sleep for a bit
			select( undef, undef, undef, 0.025 );

			next NOTIFIERLOOP;
		}
		debug("Retry (attempt $count) for $param");
	}



        # TODO sanity checks

        my $retstr = `$cmd $param`;
        chomp($retstr);
        my $retval = ( ( $? == -1 ) ? 3 : ( $? >> 8 ) );

        $outqueue->enqueue("$id;$retval;$retstr");
    }

}


# the escalation thread is responsible for internal escalations
# it schedules fake alerts into the command queue
sub spawnEscalationThread
{
    my ( $cmdq, $escqueue ) = @_;

    ESCALATIONLOOP: while ( my $msg = $escqueue->dequeue )
    {
        # 
        my ( $qstart, $start, $param ) = split( /;/, $msg, 3 );


		my $timeToWait = $conf->{escalator}->{timeToWait};
		if (!(defined($timeToWait)))
		{
			$timeToWait = 120;
		}

		my $timeTillAbandon = $conf->{escalator}->{abandonAfter};

        # abandon old escalations
        if (defined($timeTillAbandon) and (($start + $timeTillAbandon) < time()))
        {
            # drop it
            debug("Escalation is over $timeTillAbandon seconds old - dropping it");
            next ESCALATIONLOOP;
        }

		# be careful! we don't use timezones
		if (($qstart + $timeToWait) > time())
		{
			# escalation is not old enough, requeue
			$escqueue->enqueue($msg);

			# sleep for a bit
			select( undef, undef, undef, 0.025 );

			next ESCALATIONLOOP;
		}

        # 2nd parameter is blank to make sure that the unique_id is autogenerated!
        $cmdq->enqueue('escalation;;'.$param);

        # sleep for a bit
        select( undef, undef, undef, 0.025 );
    }

}

# open a pipe and accept commands
sub spawnCommandPipeThread
{

    my ( $queue, $config ) = @_;
    my $input;
    my $pipe = $$config{pipePath};

    create_pipe($pipe);

    sysopen( PIPE, $pipe, O_RDWR );

    my $sel = IO::Select->new();
    $sel->add( \*PIPE );

    while ( $sel->can_read() )
    {
        sysread PIPE, $input, 1024;
        $queue->enqueue($input);
    }

}

# open a socket and accept commands
sub spawnCommandSocketThread
{

	my ( $queue, $config ) = @_;
	my $input;
	my $port = $$config{socketPort};
    my $pool = Thread::Queue->new;
    my $closedConn = Thread::Queue->new;
    my %openConnections;

    for (my $i=0; $i<$$config{socketMaxConns}; $i++) {
        # set stack_size ?
        threads->new(\&readSocket, $queue, $pool, $closedConn);
    }

	my $sock = new IO::Socket::INET (
		Proto	=> 'tcp',
		LocalPort	=> $port,
		Listen	=> 1,
		Reuse	=> 1
	);

    my $bitmask = pack("C", 2**fileno($sock));

    while (1==1)
    {
        my $ready;
        select($ready = $bitmask, undef, undef, 0.5);
        if (($ready & $bitmask ) ne pack("C", 0))
        {
            my $conn = $sock->accept();
            my($dummy, $ipaddr) = sockaddr_in($conn->peername);
            debug("incoming connection from ".join('.', unpack('C4', $ipaddr)));
            $pool->enqueue(fileno($conn));
            $openConnections{fileno($conn)} = $conn;
        }

        if (my $closeme = $closedConn->dequeue_nb())
        {
            debug("closing FD $closeme");
            undef ($openConnections{$closeme});
        }
    }

}

# called by the spawnCommandSocketThread function for each new connection
sub readSocket
{
	my ($queue, $pool, $closed) = @_;
	my $input;

	while (my $fileno = $pool->dequeue())
    {
        open(CONN, '<&='.$fileno);
        while (defined ($input = <CONN> ))
        {
		    $queue->enqueue($input);
        }
        close CONN;
        $closed->enqueue($fileno);
    }
}

# called by the spawnCommandPipeThread to create a FIFO
sub create_pipe
{
    my $pipe = shift;

    debug("creating pipe $pipe");
    if ( -e $pipe )
    {
        unlink $pipe or die "Cannot delete pipe $pipe\n";
    }
    mkfifo( $pipe, 0666 ) or die "Cannot create pipe $pipe\n";

}


# provides stats for the watchdog.
# N.B. that the Proc::ProcessTable Module is not thread-aware
# which makes it useless for this daemon
sub getStats
{
    my ($pid) = @_;
#    my $t = new Proc::ProcessTable;
#
#    foreach my $p (@{$t->table})
#    {
#        next if not $p->pid eq $$;
#        return ($p->{rss},$p->{size});
#    }
    my $stats = `ps -o pid,rss,vsz -p $pid`;
    $stats =~ /\s+(\d+)\s+(\d+)\s+(\d+)/;
    if ($1 eq $pid)
    {
        return ($2, $3);
    }
    return (undef, undef);
}


# this thread watches the process and restarts if necessary
sub spawnWatchdogThread
{
    my ($config) = @_;
    my $rssMax = $$config{watchdogMaxRSS};
    my $vssMax = $$config{watchdogMaxVSS};
    my $maxTime = $$config{watchdogMaxRuntime};

    while (1==1)
    {
        my ($rss, $size) = getStats($$);

        #TODO sanity checks

        if (
            (defined($rssMax) and ($rss > $rssMax))
           or
            (defined($vssMax) and ($size > $vssMax))
           or
            (defined($maxTime) and (time() > ($processStart + $maxTime)))
           )
        {
            debug("WATCHDOG: Limits exceeded (rss=$rss, vss=$size, time=".(time()-$processStart)."s)");
            exec $0 or die "Failed to respawn self";
        }

        # check that all threads are running TODO
        sleep 10;
    }
}

1;
